# Hungarian Algorithm（匈牙利算法）

`匈牙利算法(Hungarian Algorithm)是一种组合优化算法(combinatorial optimization algorithm)，用于求解指派问题(assignment problem)，算法时间复杂度为O(n3)。Harold Kuhn发表于1955年，由于该算法基于两位匈牙利数学家的早期研究成果，所以被称作“匈牙利算法”。`                                                                       —— 维基百科



## 指派问题

### 问题描述

研究生导师这里有四个任务(A,B,C,D)需要完成，他有四个学生(甲,乙,丙,丁)，由于每个学生的擅长方向不一样，完成四个任务的耗时也不一样，如果每个学生完成各项任务的耗时如下表所示，试问导师如何安排工作能够保证在最短时间内完成所有任务呢？

| 同学/任务 | A    | B    | C    | D    |
| --------- | ---- | ---- | ---- | ---- |
| 甲        | 6    | 7    | 11   | 2    |
| 乙        | 4    | 5    | 9    | 8    |
| 丙        | 3    | 1    | 10   | 4    |
| 丁        | 5    | 9    | 8    | 2    |

### 求解

我们将以上任务分配问题用如下开销矩阵来表示：
$$
\begin{bmatrix}
 6 &7 &11 &2 \\ 
 4 &5 &9 &8 \\
 3 &1 &10 &4 \\
 5 &9 &8 &2
\end{bmatrix}
$$


#### step1 将开销矩阵每行减去该行最小值

- 数学操作：找出每行的最小值，然后该行所有值减去这个最小值，那么每行都会有一个为0的元素。
- 物理意义：确定每个学生最应该分配的工作；每行都对应了一个学生，0所在的列代表该学生完成对应任务效率最高。

$$
M=
\begin{bmatrix}
 6 &7 &11 &2 \\ 
 4 &5 &9 &8 \\
 3 &1 &10 &4 \\
 5 &9 &8 &2
\end{bmatrix}
->\begin{bmatrix}
 4 &5 &9 &0 \\ 
 0 &1 &5 &4 \\
 2 &0 &9 &3 \\
 3 &7 &6 &0
\end{bmatrix}
$$

确定下0是否分布在不同的列：

- 如果分布在不同的列，代表每个学生最高效处理的任务不一样，正好可以给每个学生最优的分配任务，完成指派目标；
- 如果有的列没有0，而有的列出现多个0，代表仅仅依据每个学生的擅长任务划分会造成多个学生分配至同一个任务，而有的任务没分配给学生，这样继续进行**step2**；

#### step2 将开销矩阵每列减去该行最小值

- 数学操作：找出每列的最小值，然后该列所有值减去这个最小值，其实这样只会改变没有0的列，有0的列保存不变。
- 物理意义：确定一下没有分配出去的任务应该指定哪个学生去完成。

$$
\begin{bmatrix}
 4 &5 &9 &0 \\ 
 0 &1 &5 &4 \\
 2 &0 &9 &3 \\
 3 &7 &6 &0
\end{bmatrix}
->\begin{bmatrix}
 4 &5 &4 &0 \\ 
 0 &1 &0 &4 \\
 2 &0 &4 &3 \\
 3 &7 &1 &0
\end{bmatrix}
$$

#### step3 确定独立0元素

1、从只有一个0的**行**开始，在0所在的位置加圈，即标记为$\circledcirc$，如果$\circledcirc$所在的**列**还有0，则将其划掉，即标记为$\oslash$，也就是每个人依次指派一个任务，如果任务指派，那么不再考虑其他人。按照这个过程，处理到最后一行。
$$
\begin{bmatrix}
 4 &5 &4 &0 \\ 
 0 &1 &0 &4 \\
 2 &0 &4 &3 \\
 3 &7 &1 &0
\end{bmatrix}->
\begin{bmatrix}
 4 &5 &4 &\circledcirc \\ 
 0 &1 &0 &4 \\
 2 &\circledcirc &4 &3 \\
 3 &7 &1 &\oslash
\end{bmatrix}
$$
2、从只有一个0的**列**开始（标记为$\oslash$的不计在内），在0所在的位置加圈（标记为$\circledcirc$），如果$\circledcirc$所在的**行**还有0，则将其划掉（标记为$\oslash$），也就是没有指派出去的任务找到最合适的学生，如果该学生被指派，那么不再考虑给他安排其他任务。按照这个过程，处理到最后一列。
$$
\begin{bmatrix}
 4 &5 &4 &\circledcirc \\ 
 0 &1 &0 &4 \\
 2 &\circledcirc &4 &3 \\
 3 &7 &1 &\oslash
\end{bmatrix}->
\begin{bmatrix}
 4 &5 &4 &\circledcirc \\ 
\circledcirc &1 &\oslash &4 \\
 2 &\circledcirc &4 &3 \\
 3 &7 &1 &\oslash
\end{bmatrix}
$$
3、若仍有没有被标记的0元素，且同行（列）的0元素至少有两个，那么比较这行各0元素所在列中包含有0元素的数目，选择0元素较少的列对应的0元素标记为$\circledcirc$，即表示优先将可选择性少的任务分配出去，然后划掉同行同列其他的0元素。反复进行，直到所有的0元素都被**加圈**或**划掉**为止。

4、若加圈（标记为$\circledcirc$）的元素数目(m=3)等于矩阵的阶数(n=4)，那么完成最优匹配，指派结束，否则进入step4。

#### step4: 作最少直线覆盖所有0元素

1、对没有加圈（标记为$\circledcirc$）的行标记，即打"√"；

2、对已经打"√"的行所含$\oslash$元素的列打"√"；

3、再对打有"√"的列中含$\circledcirc$元素的行打"√"；

4、重复1,2,3直到得不出新的打"√"的行、列为止；

5、对**没有打"√"的行画横线**，**有打"√"的列**画纵线，得到所有覆盖所有0元素的最少直线数，记为$l$。

<img src="sources\minus_line.png" style="zoom:70%;" />

直观理解就是：

我们首先找到并标记没有分配到任务的同学（标记所在的行），然后找到该同学最“擅长”的任务（标记所在的列），其次找到并标记该项任务分配给了哪个同学（标记所在的行）。这样就找到了哪些已分配任务的同学与未分配任务的同学有冲突，就是因为这些被分配任务的同学“抢走”了工作，没办法，谁让人家“捷足先登”了呢）。

注意：

这里直线数 $l$ 应该与加圈（标记为$\circledcirc$）的元素数目 $m$ 相同，否则运算步骤错误。由于$l=m<n$，则继续进行下一步。

#### step5 找到未被直线覆盖最小的元素

1、没有直线通过的最小元素值为1，并且将所有没有直线通过的元素减去这个最小值，直线交点所在的元素加上最小值。
$$
\begin{bmatrix}
 4 &5 &4 &0 \\ 
 0 &1 &0 &4 \\
 2 &0 &4 &3 \\
 3 &7 &1 &0
\end{bmatrix}->
\begin{bmatrix}
 3 &4 &3 &0 \\ 
 0 &1 &0 &5 \\
 2 &0 &4 &4 \\
 2 &6 &0 &0
\end{bmatrix}
$$
这样做的意义是协调相互”冲突“的同学在”冲突“任务上的分配，并尝试在”冲突“之外的任务上进行重新匹配，而那个最小值是分配任务必须要”付出“的代价，由于已经分配到任务的同学不可能再给他们去分配”冲突“任务（打√的列），所以增加相应的代价使在下一轮已经分配到任务的同学**更不可能**去分配那些冲突任务。

我们可以看到，通过减去最小值，多出了一个0，使分配灵活性更高。也即使第四个同学**有可能**分配到任务C，而不像前面一样，第四个同学在最优情况下非得分配任务D！

2、然后重复step2~step4，重新指派。
$$
\begin{bmatrix}
 3 &4 &3 &0 \\ 
 0 &1 &0 &5 \\
 2 &0 &4 &4 \\
 2 &6 &0 &0
\end{bmatrix}->
\begin{bmatrix}
 3 &4 &3 &\circledcirc \\ 
 \circledcirc &1 &\oslash &5 \\
 2 &\circledcirc &4 &4 \\
 2 &6 &\circledcirc &\oslash
\end{bmatrix}
$$

#### step6 完美匹配

直到**加圈（标记为$\circledcirc$）的元素数目 $m$ 与矩阵的阶数n相同，即m=n**。新建一个同样大小但元素都为0的矩阵，并且将所有对应至开销矩阵中$\circledcirc$位置的元素标记为1。
$$
L=
\begin{bmatrix}
 0 &0 &0 &1 \\ 
 1 &0 &0 &0 \\
 0 &1 &0 &0 \\
 0 &0 &1 &0
\end{bmatrix}
$$
那么获取完美分配，且分配的代价为：
$$
loss = M\cdot L
$$


## 二分图



